## ADDED Requirements

### Requirement: Identifier Quoting and Option Rendering
SQL generation MUST provide helpers to quote identifiers and render option dictionaries into `key=value` clauses.

#### Scenario: Identifiers are quoted
- **GIVEN** a view with `name: user events`
- **WHEN** SQL is generated for the view
- **THEN** the view name in the `CREATE OR REPLACE VIEW` statement is wrapped in double quotes
- **AND** spaces or special characters are preserved inside the quotes.

#### Scenario: Options rendered with correct types
- **GIVEN** a view with `options` containing a string, boolean, and number
- **WHEN** SQL is generated
- **THEN** string options are rendered as `key='value'`
- **AND** boolean options are rendered as `TRUE` or `FALSE`
- **AND** numeric options are rendered as bare numbers.

### Requirement: View SQL Generation Per Source Type
`generate_view_sql(view)` MUST produce a `CREATE OR REPLACE VIEW` statement for each supported source type and for raw SQL views.

#### Scenario: Raw SQL view body preserved
- **GIVEN** a view with `sql` set and no `source`, `uri`, `database`, `table`, or `catalog`
- **WHEN** `generate_view_sql` is called
- **THEN** the returned SQL uses `CREATE OR REPLACE VIEW "<name>" AS` followed by the raw SQL body
- **AND** no additional wrappers or scan functions are injected.

#### Scenario: Parquet view uses parquet_scan
- **GIVEN** a view with `source: parquet`, a non-empty `uri`, and optional `options`
- **WHEN** `generate_view_sql` is called
- **THEN** the view body selects from `parquet_scan('<uri>'[, <options>])`
- **AND** `options` are rendered via the option rendering helper when present.

#### Scenario: Delta view uses delta_scan
- **GIVEN** a view with `source: delta` and a non-empty `uri`
- **WHEN** `generate_view_sql` is called
- **THEN** the view body selects from `delta_scan('<uri>'[, <options>])`.

#### Scenario: Iceberg view supports uri or catalog+table
- **GIVEN** a view with `source: iceberg`
- **AND** either a non-empty `uri`
- **OR** both `catalog` and `table` set
- **WHEN** `generate_view_sql` is called
- **THEN** the view body uses `iceberg_scan('<uri>'[, <options>])` for uri-based configs
- **OR** `iceberg_scan('<catalog>', '<table>'[, <options>])` for catalog-based configs.

#### Scenario: Attached database views select from database.table
- **GIVEN** a view with `source` set to `duckdb`, `sqlite`, or `postgres`
- **AND** both `database` and `table` fields populated
- **WHEN** `generate_view_sql` is called
- **THEN** the view body is `SELECT * FROM <database>.<table>`
- **AND** the database alias and table name are used as-is without additional quoting beyond what the config provides.

### Requirement: Generate SQL for All Views
`generate_all_views_sql(config)` MUST produce a deterministic multi-view SQL script, including an optional header.

#### Scenario: SQL header includes config version
- **GIVEN** a `Config` instance with a `version` field and multiple views
- **WHEN** `generate_all_views_sql` is called
- **THEN** the returned SQL begins with a comment line indicating it was generated by this tool
- **AND** a comment line including the config version.

#### Scenario: Views rendered in config order
- **GIVEN** a config with multiple views in a specific order
- **WHEN** `generate_all_views_sql` is called
- **THEN** the resulting SQL contains `CREATE OR REPLACE VIEW` statements for each view in the same order as defined in the config
- **AND** statements are separated by blank lines for readability.

