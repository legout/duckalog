"""SQL generation utilities for Duckalog views."""

from __future__ import annotations

from typing import Any, Dict

from .config import Config, ViewConfig


def quote_ident(value: str) -> str:
    """Quote an identifier using double quotes, escaping embedded quotes."""

    escaped = value.replace("\"", "\"\"")
    return f'"{escaped}"'


def _quote_literal(value: str) -> str:
    escaped = value.replace("'", "''")
    return f"'{escaped}'"


def render_options(options: Dict[str, Any]) -> str:
    """Render a dict of options into function arguments.

    Returns a string beginning with ", " when options are present, otherwise an
    empty string. Keys are sorted for deterministic output.
    """

    if not options:
        return ""

    parts = []
    for key in sorted(options):
        value = options[key]
        if isinstance(value, bool):
            rendered = "TRUE" if value else "FALSE"
        elif isinstance(value, (int, float)) and not isinstance(value, bool):
            rendered = str(value)
        elif isinstance(value, str):
            rendered = _quote_literal(value)
        else:
            raise TypeError(
                f"Unsupported option value for '{key}': {value!r}. Expected str, bool, int, or float."
            )
        parts.append(f"{key}={rendered}")

    return ", " + ", ".join(parts)


def generate_view_sql(view: ViewConfig) -> str:
    """Generate the CREATE VIEW SQL for a single view."""

    view_name = quote_ident(view.name)
    if view.sql:
        body = view.sql
    else:
        body = _render_view_body(view)

    return f"CREATE OR REPLACE VIEW {view_name} AS\n{body};"


def _render_view_body(view: ViewConfig) -> str:
    source = view.source
    if source is None:
        raise ValueError("View must define 'sql' or 'source'")

    if source in {"parquet", "delta"}:
        func = f"{source}_scan"
        assert view.uri is not None  # enforced by schema
        scan_call = f"{func}({_quote_literal(view.uri)}{render_options(view.options)})"
        return f"SELECT * FROM {scan_call}"

    if source == "iceberg":
        if view.uri:
            scan_call = f"iceberg_scan({_quote_literal(view.uri)}{render_options(view.options)})"
        else:
            assert view.catalog and view.table  # enforced by schema
            scan_call = (
                "iceberg_scan("
                f"{_quote_literal(view.catalog)}, {_quote_literal(view.table)}"
                f"{render_options(view.options)})"
            )
        return f"SELECT * FROM {scan_call}"

    if source in {"duckdb", "sqlite", "postgres"}:
        assert view.database and view.table  # enforced by schema
        return f"SELECT * FROM {view.database}.{view.table}"

    raise ValueError(f"Unsupported view source '{source}'")


def generate_all_views_sql(config: Config) -> str:
    """Generate SQL for every view in the config with a descriptive header."""

    lines = [
        "-- Generated by Duckalog",
        f"-- Config version: {config.version}",
        "",
    ]

    for index, view in enumerate(config.views):
        lines.append(generate_view_sql(view))
        if index != len(config.views) - 1:
            lines.append("")

    return "\n".join(lines)


__all__ = [
    "quote_ident",
    "render_options",
    "generate_view_sql",
    "generate_all_views_sql",
]
