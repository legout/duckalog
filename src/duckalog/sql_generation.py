"""SQL generation utilities for Duckalog views."""

from __future__ import annotations

from typing import Any

from .config import Config, ViewConfig
from .secret_types import (
    S3SecretConfig,
    AzureSecretConfig,
    GCSSecretConfig,
    HTTPSecretConfig,
    PostgresSecretConfig,
    MySQLSecretConfig,
)


def quote_ident(value: str) -> str:
    """Quote a SQL identifier using double quotes.

    This helper wraps a string in double quotes and escapes any embedded
    double quotes according to SQL rules.

    Args:
        value: Identifier to quote (for example, a view or column name).

    Returns:
        The identifier wrapped in double quotes.

    Example:
        >>> quote_ident("events")
        '"events"'
    """

    escaped = value.replace('"', '""')
    return f'"{escaped}"'


def _quote_literal(value: str) -> str:
    escaped = value.replace("'", "''")
    return f"'{escaped}'"


def render_options(options: dict[str, Any]) -> str:
    """Render a mapping of options into scan-function arguments.

    The resulting string is suitable for appending to a ``*_scan`` function
    call. Keys are sorted alphabetically to keep output deterministic.

    Args:
        options: Mapping of option name to value (str, bool, int, or float).

    Returns:
        A string that starts with ``, `` when options are present (for example,
        ``", hive_partitioning=TRUE"``) or an empty string when no options
        are provided.

    Raises:
        TypeError: If a value has a type that cannot be rendered safely.
    """

    if not options:
        return ""

    parts = []
    for key in sorted(options):
        value = options[key]
        if isinstance(value, bool):
            rendered = "TRUE" if value else "FALSE"
        elif isinstance(value, (int, float)) and not isinstance(value, bool):
            rendered = str(value)
        elif isinstance(value, str):
            rendered = _quote_literal(value)
        else:
            raise TypeError(
                f"Unsupported option value for '{key}': {value!r}. Expected str, bool, int, or float."
            )
        parts.append(f"{key}={rendered}")

    return ", " + ", ".join(parts)


def generate_view_sql(view: ViewConfig) -> str:
    """Generate a ``CREATE OR REPLACE VIEW`` statement for a single view.

    Args:
        view: The :class:`ViewConfig` to generate SQL for.

    Returns:
        A single SQL statement that creates or replaces the view.
    """

    view_name = quote_ident(view.name)
    if view.sql:
        body = view.sql
    else:
        body = _render_view_body(view)

    return f"CREATE OR REPLACE VIEW {view_name} AS\n{body};"


def _render_view_body(view: ViewConfig) -> str:
    source = view.source
    if source is None:
        raise ValueError("View must define 'sql' or 'source'")

    if source in {"parquet", "delta"}:
        func = f"{source}_scan"
        assert view.uri is not None  # enforced by schema
        scan_call = f"{func}({_quote_literal(view.uri)}{render_options(view.options)})"
        return f"SELECT * FROM {scan_call}"

    if source == "iceberg":
        if view.uri:
            scan_call = f"iceberg_scan({_quote_literal(view.uri)}{render_options(view.options)})"
        else:
            assert view.catalog and view.table  # enforced by schema
            scan_call = (
                "iceberg_scan("
                f"{_quote_literal(view.catalog)}, {_quote_literal(view.table)}"
                f"{render_options(view.options)})"
            )
        return f"SELECT * FROM {scan_call}"

    if source in {"duckdb", "sqlite", "postgres"}:
        assert view.database and view.table  # enforced by schema
        return f"SELECT * FROM {view.database}.{view.table}"

    raise ValueError(f"Unsupported view source '{source}'")


def generate_all_views_sql(config: Config, include_secrets: bool = False) -> str:
    """Generate SQL for all views in a configuration.

    The output includes a descriptive header with the config version followed
    by a ``CREATE OR REPLACE VIEW`` statement for each view in the order they
    appear in the configuration.

    Args:
        config: The validated :class:`Config` instance to render.
        include_secrets: Whether to include CREATE SECRET statements for secrets.

    Returns:
        A multi-statement SQL script suitable for use as a catalog definition.
    """
    lines = [
        "-- Generated by Duckalog",
        f"-- Config version: {config.version}",
        "",
    ]

    for index, view in enumerate(config.views):
        lines.append(generate_view_sql(view))
        if index != len(config.views) - 1:
            lines.append("")

    # Add secrets if requested
    if include_secrets and config.duckdb.secrets:
        lines.extend(["", "-- Secrets"])
        for secret in config.duckdb.secrets:
            lines.append(generate_secret_sql(secret))

    return "\n".join(lines)


def generate_secret_sql(secret: "SecretConfig") -> str:
    """Generate CREATE SECRET statement for a DuckDB secret.

    Args:
        secret: Secret configuration object.

    Returns:
        SQL CREATE SECRET statement.
    """
    from .config import (
        S3SecretConfig,
        AzureSecretConfig,
        GCSSecretConfig,
        HTTPSecretConfig,
        PostgresSecretConfig,
        MySQLSecretConfig,
    )

    # Handle different secret types
    if isinstance(secret, S3SecretConfig):
        if secret.key_id and secret.secret:
            return (
                f"CREATE OR REPLACE SECRET {secret.key_id} "
                f"(ID '{secret.key_id}', SECRET '{secret.secret}', "
                f"SCOPE 's3');"
            )
        elif secret.key_id:
            return (
                f"CREATE OR REPLACE SECRET {secret.key_id} "
                f"(ID '{secret.key_id}', SECRET '{secret.secret}', "
                f"SCOPE 's3');"
            )
        else:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE S3, KEY_ID '{secret.key_id}', SECRET '{secret.secret}', "
                f"SCOPE 's3');"
            )

    elif isinstance(secret, AzureSecretConfig):
        if secret.connection_string:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE AZURE, CONNECTION_STRING '{secret.connection_string}');"
            )
        else:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE AZURE, TENANT_ID '{secret.tenant_id}', "
                f"CLIENT_ID '{secret.client_id}', "
                f"CLIENT_SECRET '{secret.client_secret}');"
            )

    elif isinstance(secret, GCSSecretConfig):
        if secret.service_account_key:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE GCS, SERVICE_ACCOUNT_KEY '{secret.service_account_key}');"
            )
        elif secret.json_key:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE GCS, JSON_KEY '{secret.json_key}');"
            )
        else:
            return f"CREATE OR REPLACE SECRET {secret.name} (TYPE GCS);"

    elif isinstance(secret, HTTPSecretConfig):
        if secret.bearer_token:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE HTTP, BEARER_TOKEN '{secret.bearer_token}');"
            )
        elif secret.header:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE HTTP, HEADER '{secret.header}');"
            )
        else:
            return f"CREATE OR REPLACE SECRET {secret.name} (TYPE HTTP);"

    elif isinstance(secret, PostgresSecretConfig):
        if secret.connection_string:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE POSTGRES, CONNECTION_STRING '{secret.connection_string}');"
            )
        else:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE POSTGRES, HOST '{secret.host}', "
                f"PORT '{secret.port}', "
                f"DATABASE '{secret.database}', "
                f"USER '{secret.user}', "
                f"PASSWORD '{secret.password}');"
            )

    elif isinstance(secret, MySQLSecretConfig):
        if secret.connection_string:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE MYSQL, CONNECTION_STRING '{secret.connection_string}');"
            )
        else:
            return (
                f"CREATE OR REPLACE SECRET {secret.name} "
                f"(TYPE MYSQL, HOST '{secret.host}', "
                f"PORT '{secret.port}', "
                f"DATABASE '{secret.database}', "
                f"USER '{secret.user}', "
                f"PASSWORD '{secret.password}');"
            )

    else:
        # Fallback for unknown secret types
        return f"CREATE OR REPLACE SECRET {secret.name} (TYPE {secret.type.upper()});"


__all__ = [
    "quote_ident",
    "render_options",
    "generate_view_sql",
    "generate_all_views_sql",
    "generate_secret_sql",
]
